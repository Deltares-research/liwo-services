import json
import io
import zipfile
import time
import logging
import os
import pathlib
import tempfile
import subprocess

import flask
from flask import Flask, jsonify, request
from flask_cors import CORS
from sqlalchemy import create_engine, MetaData, Table
import sqlalchemy.engine.url
from sqlalchemy.orm import mapper, sessionmaker

from flask_sqlalchemy import SQLAlchemy

# side effect loads the env
import liwo_services
import liwo_services.settings

logger = logging.getLogger(__name__)

def create_app_db():
    """load the dot env values"""
    liwo_services.settings.load_env()
    # Create the application instance
    app = Flask(__name__)
    # add db settings
    app.config['SQLALCHEMY_DATABASE_URI'] = os.environ['SQLALCHEMY_DATABASE_URI']
    # add cors headers
    CORS(app)
    # load the database
    db = SQLAlchemy(app)
    logger.info("loaded database %s", app.config['SQLALCHEMY_DATABASE_URI'])
    return app, db


app, db = create_app_db()

# Create a URL route in our application for "/"
@app.route('/')
def home():
    """
    This function just responds to the browser ULR
    localhost:5000/

    :return:        the rendered template 'home.html'
    """
    return {'version': liwo_services.__version__}


@app.route('/liwo.ws/Authentication.asmx/Login', methods=["OPTIONS", "POST"])
def loadLayerSets():
    """
    returns maplayersets. Login is not used anymore, but frontend still expects this.
    frontend will send body {
    username: 'anonymous@rws.nl',
    password: '',
    mode: ''}

    TODO: remove Login part and only return json generated by postgresql function
    """


    rs = db.session.execute('SELECT website.sp_selectjson_maplayersets_groupedby_mapcategories()')

    result = rs.fetchall()

    layersets_dict = {
        "mode": "open",
        "layersets": result[0][0],
        "loggedIn": False,
        "liwokey": "-1",
        "error": "",
        "user": {
            "email": "",
            "message": "",
            "role": "Guest",
            "name": "",
            "organisation": "",
            "tools": [],
            "mymaps": [],
            "mapextent": "",
            "webserviceURL": "http://localhost:5000/liwo.ws/",
            "administrator": "false"
        }
    }

    layersets_string = json.dumps(layersets_dict)

    return {"d": layersets_string}

@app.route('/liwo.ws/Tools/FloodImage.asmx/GetScenariosPerBreachGeneric', methods=["POST"])
def loadBreachLayer():
    """
    Return Scenarios for a breachlocation.

    body: {
      breachid: breachId,
      layername: layerName
    })

     Based on layername a setname is defined.
     In the database function this is directly converted back to the layername.
     TODO: remove setname directly use layerName.
    """

    body = request.json

    # Set names according to c-sharp backend
    set_names = {
        "waterdiepte": "Waterdiepte_flood_scenario_set",
        "stroomsnelheid": "Stroomsnelheid_flood_scenario_set",
        "stijgsnelheid": "Stijgsnelheid_flood_scenario_set",
        "schade": "Schade_flood_scenario_set",
        "slachtoffers": "Slachtoffers_flood_scenario_set",
        "getroffenen": "Getroffenen_flood_scenario_set",
        "aankomsttijd": "Aankomsttijd_flood_scenario_set"
    }

    # Default value for setname
    default_set_name = "Waterdiepte_flood_scenario_set"
    set_name = set_names.get(body['layername'], default_set_name)
    breach_id = body['breachid']

    # define query with parameters
    query = "SELECT website.sp_selectjson_maplayerset_floodscen_breachlocation_id_generic(:breach_id, :set_name)"

    rs = db.session.execute(query, breach_id, set_name)
    result = rs.fetchall()
    return {"d": json.dumps(result[0][0])}


@app.route('/liwo.ws/Maps.asmx/GetLayerSet', methods=["POST"])
def loadLayerSetById():
    """
    body: { id }
    """
    body = request.json
    layerset_id = body['id']

    # TODO: use params option in execute.
    query = "SELECT website.sp_selectjson_layerset_layerset_id(:layerset_id)"

    rs = db.session.execute(query, layerset_id=layerset_id)
    result = rs.fetchall()
    return {"d": json.dumps(result[0][0])}

@app.route('/liwo.ws/Maps.asmx/GetBreachLocationId', methods=["POST"])
def getFeatureIdByScenarioId():
    """
    body:{ mapid: scenarioId }
    """
    body = request.json
    flood_simulation_id = body['floodsimulationid']

    # TODO: use params option in execute
    query = "SELECT static_information.sp_selectjson_breachlocationid(:flood_simulation_id)"

    rs = db.session.execute(query, flood_simulation_id=flood_simulation_id)
    result = rs.fetchall()

    return {"d": json.dumps(result[0][0])}


@app.route('/liwo.ws/Maps.asmx/DownloadZipFileDataLayers', methods=["POST"])
def download_zip():
    """
    body: {"layers":"scenario_18734,gebiedsindeling_doorbraaklocaties_buitendijks","name":"test"}
    """
    body = request.json
    layers = body.get('layers', "").split(',')
    layers_str = body.get('layers', '')
    name = body.get("name", "").strip()
    if not name:
        name = "DownloadLIWO"

    data_dir = pathlib.Path('/var/local/geoserver')


    # security check
    for layer in layers:
        if '..' in layer or layer.startswith('/'):
            raise ValueError('Security issue: layer name not valid')

    # TODO Add custom log stream for invalid layers
    log_stream = io.StringIO()
    # define a handler
    layer_logger = logging.getLogger('layer-export')
    layer_logger.setLevel(logging.DEBUG)
    for handler in layer_logger.handlers:
        layer_logger.removeHandler(handler)
    # add the new handler
    handler = logging.StreamHandler(log_stream)
    layer_logger.addHandler(handler)

    query = "SELECT website.sp_select_filepaths_maplayers(:map_layers)"
    rs = db.session.execute(query, dict(map_layers=layers_str))
    result = rs.fetchall()
    logger.info(f"{result}")

    # lookup relevant parts for cli script
    url = sqlalchemy.engine.url.make_url(app.config['SQLALCHEMY_DATABASE_URI'])

    zip_stream = io.BytesIO()
    with zipfile.ZipFile(zip_stream, 'w') as zf:

        for row in result:
            items = row[0].split(',')
            # this is an odd format
            # ('static_information.tbl_breachlocations,shape1,static_information_geodata.infrastructuur_dijkringen,shape',)
            for item, type_ in zip(items[:-1:2], items[1:-1:2]):

                if 'shape' in type_:
                    with tempfile.TemporaryDirectory(prefix='liwo_') as tmp_dir:
                        # export table to shapefile
                        table = item
                        filename = table.split('.')[-1]
                        path = pathlib.Path(tmp_dir) / (filename + '.shp')
                        args = [
                            "pgsql2shp",
                            "-f", str(path),
                            "-h", url.host,
                            "-p", str(url.port),
                            "-u", url.username,
                            "-P", url.password,
                            url.database,
                            table
                        ]
                        # TODO: how to just pass args
                        cmd = " ".join(args)
                        process = subprocess.run(cmd, shell=True, capture_output=True)
                        if process.returncode:
                            layer_logger.debug(f"error exporting {table}: {' '.join(args)}\nstdout:\n{process.stdout}\nstderr:\n {process.stderr}")
                        for f in pathlib.Path(tmp_dir).glob('*'):
                            zf.write(f, f.name)
                        layer_logger.debug(f"table {table} added")
                elif 'tif' in type_:
                    path = data_dir / item.lstrip('/')
                    zf.write(path, path.name)
                    layer_logger.debug(f"item {item} not added")
        zf.writestr('log.txt', log_stream.getvalue())


    # rewind
    zip_stream.seek(0)

    resp = flask.send_file(
        zip_stream,
        mimetype='application/zip',
        attachment_filename="{}.zip".format(name),
        as_attachment=True
    )
    return resp
